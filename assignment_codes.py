# -*- coding: utf-8 -*-
"""â€œAssignment_Codes.ipynb

Automatically generated by Colab.

### Imports
"""

import pandas as pd
import numpy as np
import statsmodels.api as sm
import matplotlib.pyplot as plt
from pandas.tseries.offsets import DateOffset,MonthEnd
from IPython.display import display
import seaborn as sns

"""
###Initialise
"""

START_DATE='2009-01-01'
END_DATE='2022-12-31'

VAR_LEVEL=0.99
VAR_SIMULATIONS=100000
CONFIDENCE_LEVEL=0.05

"""### Data Loading"""

STOCKS_CSV_FILE_ID="1plHG9z6NfPDHsaa5yBZxppO3Qs3gIJIu"
FACTORS_CSV_FILE_ID="1R16yvEAEIlftE9IiuulX_PlT9NfJdNZ2"

STOCKS_FILE=f"https://drive.google.com/uc?export=download&id={STOCKS_CSV_FILE_ID}"
FACTORS_FILE=f"https://drive.google.com/uc?export=download&id={FACTORS_CSV_FILE_ID}"

"""### Helper Functions"""

def load_and_prepare_data(stock_file,factor_file,start_date,end_date):
    # 1. Load data
    stock_df=pd.read_csv(stock_file,na_values=["#N/A N/A"])
    stock_df['Dates']=pd.to_datetime(stock_df['Dates'],format='%d-%m-%Y')
    stock_df=stock_df.set_index('Dates')

    factor_df=pd.read_csv(factor_file)
    factor_df['Date']=pd.to_datetime(factor_df['Date'],format='%d-%m-%Y')
    factor_df=factor_df.set_index('Date')

    factor_df['MF']=factor_df['MF'] / 100.0

    # Separate
    nifty_prices=stock_df[['NIFTY Index']]
    stock_prices=stock_df.drop(columns=['NIFTY Index'])
    stock_prices=stock_prices.loc[start_date:end_date]

    # drop incosistent stoicks
    original_stock_count=stock_prices.shape[1]
    stock_prices=stock_prices.dropna(axis=1,how='any')
    new_count=stock_prices.shape[1]
    print(f"Dropped {original_stock_count - new_count} stock due to missing data. {new_count} stock remaining.")

    if new_count== 0:
        raise ValueError("Error: All stock were dropped. Check 'Stocks_data.csv' for NaNs.")

    # align to trading dates
    common_dates=stock_prices.index.intersection(factor_df.index).intersection(nifty_prices.index)

    stock_prices=stock_prices.loc[common_dates].sort_index()
    nifty_prices=nifty_prices.loc[common_dates].sort_index()
    factor_df=factor_df.loc[common_dates].sort_index()

    #calculate simple returns
    stock_returns=stock_prices.pct_change()
    nifty_returns=nifty_prices['NIFTY Index'].pct_change()

    #common return dates
    combined_df=pd.concat([stock_returns,nifty_returns,factor_df],axis=1)
    combined_df=combined_df.iloc[1:]

    stock_names=stock_prices.columns.tolist()
    stock_returns=combined_df[stock_names]
    nifty_returns=combined_df['NIFTY Index']
    factor_df=combined_df[['MF','RF']]

    print("Data loading and preparation complete.")
    return stock_returns,nifty_returns,factor_df,stock_names

# Portfolio Strategies
def get_gmv_weights(cov_matrix):
    inv_cov=np.linalg.inv(cov_matrix)
    ones=np.ones(len(cov_matrix))
    w=(inv_cov @ ones) / (ones.T @ inv_cov @ ones)
    return w

def get_mv_tangency_weights(mean_excess_returns,cov_matrix):
    inv_cov=np.linalg.inv(cov_matrix)
    w=(inv_cov @ mean_excess_returns) / (np.ones(len(mean_excess_returns)).T @ inv_cov @ mean_excess_returns)
    w=w / np.sum(w) # Force weights to sum to 1
    return w

def get_ew_weights(num_stock):
    return np.array([1.0 / num_stock] * num_stock)

def get_active_weights(stock_returns,mf_returns,rf_series,stock_names):
    selected_stock=[]

    for stock in stock_names:
        y=stock_returns[stock] - rf_series
        X=mf_returns
        X=sm.add_constant(X)
        model=sm.OLS(y,X,missing='drop').fit()
        alpha_pvalue=model.pvalues['const']

        # p-value < 0.05
        if alpha_pvalue < CONFIDENCE_LEVEL:
            selected_stock.append(stock)

    if not selected_stock:
        return "MARKET" # Fallback to market portfolio
    else:
        # Form an equal-weighted portfolio of selected stock
        weights=np.zeros(len(stock_names))
        selected_indices=[stock_names.index(s) for s in selected_stock]
        weights[selected_indices]=1.0 / len(selected_stock)
        return weights



def calculate_holding_return(daily_returns_series):
    if daily_returns_series.empty:
        return 0.0
    return (1 + daily_returns_series).prod() - 1

def calculate_historical_var(daily_form_returns,L_days,level=VAR_LEVEL,n_sims=VAR_SIMULATIONS):
    #estimates L-day VaR using historical simulation.
    if daily_form_returns.empty or L_days== 0:
        return 0.0

    n_form_days=len(daily_form_returns)
    random_indices=np.random.randint(0,n_form_days,size=(n_sims,L_days))
    sim_daily_returns=daily_form_returns.iloc[random_indices.flatten()].values.reshape(n_sims,L_days)
    sim_L_day_returns=(1 + sim_daily_returns).prod(axis=1) - 1

    var_quantile=1.0 - level
    sim_L_day_returns=np.nan_to_num(sim_L_day_returns)
    VaR_estimate=-np.percentile(sim_L_day_returns,100 * var_quantile)

    return VaR_estimate

"""### Main Backtest Logic"""

def run_backtest(stock_returns,nifty_returns,factor_df,stock_names):
    print("Starting rolling window backtest")

    window_ends=pd.date_range(start=START_DATE,end=END_DATE,freq='Q-DEC')

    results_data=[]
    var_data=[]

    for i,holding_end in enumerate(window_ends):
        if i < 2: # need  6 months for formation
            continue

        holding_start=holding_end - MonthEnd(2)
        form_end=holding_start - DateOffset(days=1)
        form_start=form_end - MonthEnd(5)
        form_start=form_start + DateOffset(days=1)

        if form_start < stock_returns.index.min():
            continue

        if holding_end > pd.to_datetime(END_DATE):
            holding_end=pd.to_datetime(END_DATE)
            if holding_start > holding_end:
                break

        window_label=holding_end.strftime('%Y-%m-%d')
        print(f"Processing window for holding period ending {window_label}...")

        # Slice Data
        form_stock_ret=stock_returns.loc[form_start:form_end]
        form_factor=factor_df.loc[form_start:form_end]
        hold_stock_ret=stock_returns.loc[holding_start:holding_end]
        hold_nifty_ret=nifty_returns.loc[holding_start:holding_end]

        if form_stock_ret.empty or hold_stock_ret.empty:
            print(f"  Skipping window {window_label}: Not enough data.")
            continue

        # Portfolio construction
        cov_matrix=form_stock_ret.cov()
        mean_returns=form_stock_ret.mean()
        mean_rf=form_factor['RF'].mean()
        mean_excess_returns=mean_returns - mean_rf

        w_gmv=get_gmv_weights(cov_matrix)
        w_mv=get_mv_tangency_weights(mean_excess_returns,cov_matrix)
        w_ew=get_ew_weights(len(stock_names))
        w_active=get_active_weights(form_stock_ret,form_factor['MF'],form_factor['RF'],stock_names)

        #  VaR estimation
        L_days=len(hold_stock_ret)

        form_ret_gmv=(form_stock_ret * w_gmv).sum(axis=1)
        form_ret_mv=(form_stock_ret * w_mv).sum(axis=1)
        form_ret_ew=(form_stock_ret * w_ew).sum(axis=1)

        var_gmv=calculate_historical_var(form_ret_gmv,L_days)
        var_mv=calculate_historical_var(form_ret_mv,L_days)
        var_ew=calculate_historical_var(form_ret_ew,L_days)

        if isinstance(w_active,str) and w_active== "MARKET":
            form_ret_active=nifty_returns.loc[form_start:form_end]
        else:
            form_ret_active=(form_stock_ret * w_active).sum(axis=1)
        var_active=calculate_historical_var(form_ret_active,L_days)

        # Realized holding returns
        ret_gmv=calculate_holding_return((hold_stock_ret * w_gmv).sum(axis=1))
        ret_mv=calculate_holding_return((hold_stock_ret * w_mv).sum(axis=1))
        ret_ew=calculate_holding_return((hold_stock_ret * w_ew).sum(axis=1))
        ret_nifty=calculate_holding_return(hold_nifty_ret)

        if isinstance(w_active,str) and w_active== "MARKET":
            ret_active=ret_nifty
        else:
            ret_active=calculate_holding_return((hold_stock_ret * w_active).sum(axis=1))

        #  Store Results
        results_data.append({
            'Date': holding_end,'GMV': ret_gmv,'MV': ret_mv,'EW': ret_ew,
            'Active': ret_active,'NIFTY50': ret_nifty})

        var_data.append({
            'Date': holding_end,
            'VaR_GMV': var_gmv,'Ret_GMV': ret_gmv,
            'VaR_MV': var_mv,'Ret_MV': ret_mv,
            'VaR_EW': var_ew,'Ret_EW': ret_ew,
            'VaR_Active': var_active,'Ret_Active': ret_active,})

    print("Backtest complete.")

    # result dataframes
    results_df=pd.DataFrame(results_data).set_index('Date')
    var_df=pd.DataFrame(var_data).set_index('Date')

    return results_df,var_df

"""### Reporting Function"""

def generate_reports(results_df,var_df,factor_df):
    default_rc_params=plt.rcParams.copy()

    plt.rcParams.update({
        'font.size': 20,
        'axes.titlesize': 24,
        'axes.labelsize': 22,
        'xtick.labelsize': 18,
        'ytick.labelsize': 18,
        'legend.fontsize': 20,
        'figure.titlesize': 26
    })
    print("Generating reports")

    # rolling returns matrix
    results_df.to_csv('rolling_returns.csv')
    print("  Saved 'rolling_returns.csv'")

    # 6a Cumulative Returns Plot
    cum_returns=(1 + results_df).cumprod()

    plt.figure(figsize=(15,9))

    #main portfolios
    plt.plot(cum_returns.index,cum_returns['GMV'],label='GMV',linestyle='-',linewidth=1.5,color='blue')
    plt.plot(cum_returns.index,cum_returns['MV'],label='MV',linestyle='-',linewidth=1.5,color='orange')


    plt.plot(cum_returns.index,cum_returns['EW'],label='EW',linestyle='-',linewidth=2.5,color='green',alpha=0.8)
    plt.plot(cum_returns.index,cum_returns['Active'],label='Active',linestyle='--',linewidth=2.0,color='red')
    plt.plot(cum_returns.index,cum_returns['NIFTY50'],label='NIFTY50',linestyle=':',linewidth=2.0,color='purple')

    plt.title('Cumulative Portfolio Returns (2009-2022)')
    plt.ylabel('Cumulative Return')
    plt.xlabel('Date')
    plt.grid(True,linestyle='--',alpha=0.6)
    plt.legend()
    plt.tight_layout()
    plt.show()

    # 6b performance Table
    N_QTR=4

    mean_return_q=results_df.mean()
    annualized_mean=(1 + mean_return_q)**N_QTR - 1
    annualized_std=results_df.std() * np.sqrt(N_QTR)
    annualized_rf=factor_df['RF'].mean()

    sharpe_ratio=(annualized_mean - annualized_rf) / annualized_std

    # information Ratio (relative to Nifty 50)
    active_return=results_df.subtract(results_df['NIFTY50'],axis=0)
    tracking_error=active_return.std() * np.sqrt(N_QTR)
    mean_active_return_q=active_return.mean()
    annualized_mean_active=mean_active_return_q * N_QTR

    information_ratio=annualized_mean_active / tracking_error

    performance_table=pd.DataFrame({
        'Annualized Mean Return': annualized_mean,
        'Annualized Std Dev': annualized_std,
        'Annualized Sharpe Ratio': sharpe_ratio,
        'Information Ratio (vs Nifty)': information_ratio
    }).T

    print("\n--- Performance Table (Problem 6b) ---")
    print(performance_table.applymap(lambda x: f"{x:.4f}")) # Format and print
    print(f"\nAnnualized Risk-Free Rate (Assumed): {annualized_rf:.4f}")

    #7c VaR Backtest Plot and Violation Count
    portfolios=['GMV','MV','EW','Active']
    fig,axes=plt.subplots(len(portfolios),1,figsize=(15,20),sharex=True)
    fig.suptitle(f'{VAR_LEVEL*100}% Historical VaR Backtest')

    print("\n--- VaR Violation Report (Problem 7b/c) ---")

    for i,ptf in enumerate(portfolios):
        ret_col=f'Ret_{ptf}'
        var_col=f'VaR_{ptf}'

        negative_var=-var_df[var_col]
        realized_ret=var_df[ret_col]

        # violation occurs if realized < -var
        violations=realized_ret < negative_var
        violation_count=violations.sum()
        violation_pct=violation_count / len(var_df)

        print(f"  {ptf} Portfolio:")
        print(f"    Violation Count: {violation_count} / {len(var_df)} ({violation_pct:.2%})")

        # plot
        ax=axes[i]
        ax.plot(realized_ret.index,realized_ret,
                label='Realized 3M Return',color='blue',alpha=0.7)
        ax.plot(realized_ret.index,negative_var,
                label=f'99% 3M VaR (Negative)',color='red',linestyle='--')

        # highlight violations
        ax.scatter(realized_ret.index[violations],
                   realized_ret[violations],
                   color='red',marker='x',label='Violation')

        ax.set_title(f'{ptf} Portfolio')
        ax.set_ylabel('Return / VaR')
        ax.grid(True,linestyle='--',alpha=0.5)
        ax.legend(loc='upper left')

    plt.xlabel('Date')
    plt.tight_layout(rect=[0,0.03,1,0.96])
    plt.show()
    print("\nAll reports generated.")

    plt.rcParams.update(default_rc_params)

"""### Execute Code"""

# Load and prepare data
stock_returns,nifty_returns,factor_df,stock_names=load_and_prepare_data(STOCKS_FILE,FACTORS_FILE,START_DATE,END_DATE)

#backtest
results_df,var_df=run_backtest(stock_returns,nifty_returns,factor_df,stock_names)

#reports
generate_reports(results_df,var_df,factor_df)
